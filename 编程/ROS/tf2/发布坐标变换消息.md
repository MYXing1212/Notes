```cpp
#include <chrono>
#include <functional>
#include <memory>

#include "geometry_msgs/msg/transform_stamped.hpp"
#include "rclcpp/rclcpp.hpp"
#include "tf2_ros/transform_broadcaster.h"

using namespace std::chrono_literals;

class FixedFrameBroadcaster : public rclcpp::Node
{
public:
  FixedFrameBroadcaster()
  : Node("fixed_frame_tf2_broadcaster")
  {
    tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);

    auto broadcast_timer_callback = [this](){
        geometry_msgs::msg::TransformStamped t;

        t.header.stamp = this->get_clock()->now();
        t.header.frame_id = "turtle1";
        t.child_frame_id = "carrot1";
        t.transform.translation.x = 0.0;
        t.transform.translation.y = 2.0;
        t.transform.translation.z = 0.0;
        t.transform.rotation.x = 0.0;
        t.transform.rotation.y = 0.0;
        t.transform.rotation.z = 0.0;
        t.transform.rotation.w = 1.0;

        tf_broadcaster_->sendTransform(t);
    };
    timer_ = this->create_wall_timer(100ms, broadcast_timer_callback);
  }

private:
  rclcpp::TimerBase::SharedPtr timer_;
  std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<FixedFrameBroadcaster>());
  rclcpp::shutdown();
  return 0;
}
```


好的，我们来详细解读这段用于 ROS 2 的 TF2 固定坐标系广播代码。这段代码是一个非常经典和基础的示例，它演示了如何持续发布一个静态的坐标变换。

如何来发布信息：坐标系A在坐标系B中如何表述！ 坐标变换可以是静态的，也可以是动态的！

### 代码功能概述

这段代码创建了一个名为 `fixed_frame_tf2_broadcaster` 的 ROS 2 节点，其核心功能是：**以 10Hz 的频率（每 100 毫秒）持续广播一个固定的坐标变换（Transform）**。这个变换描述了 `carrot1` 坐标系相对于 `turtle1` 坐标系的位置和姿态关系。

---

### 逐行详细解读

#### 1. 类定义与继承
```cpp
class FixedFrameBroadcaster : public rclcpp::Node
```
*   **`class FixedFrameBroadcaster`**: 定义了一个名为 `FixedFrameBroadcaster` 的类。
*   **`: public rclcpp::Node`**: 这表明 `FixedFrameBroadcaster` 类公开继承自 `rclcpp::Node`。继承是 C++ 中“是一个”的关系，这意味着 `FixedFrameBroadcaster` 类型的对象**就是一个** ROS 2 节点，它拥有 `rclcpp::Node` 的所有功能（比如创建定时器、发布者、获取时钟等）。

#### 2. 构造函数
```cpp
FixedFrameBroadcaster()
: Node("fixed_frame_tf2_broadcaster") // 初始化基类 Node
```
*   **`FixedFrameBroadcaster()`**: 类的构造函数。当创建这个类的对象时，会自动调用此函数。
*   **`: Node("fixed_frame_tf2_broadcaster")`**: 这是**成员初始化列表**。它在我们进入构造函数主体*之前*，初始化基类 `Node`，并将节点的名称设置为 `"fixed_frame_tf2_broadcaster"`。

#### 3. 创建 TF 广播器
```cpp
tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);
```
*   **`tf2_ros::TransformBroadcaster`**: 这是 ROS 2 TF2 库中的一个工具类。它的唯一目的就是高效地发布坐标变换消息。
*   **`std::make_shared<...>(this)`**: 在堆上动态创建一个 `TransformBroadcaster` 对象，并返回一个指向它的共享指针 (`std::shared_ptr`)。`this` 指针被传入，告诉广播器它属于当前这个节点。
*   **`tf_broadcaster_ = ...`**: 将这个共享指针赋值给类的私有成员变量 `tf_broadcaster_`，以便在类的其他成员函数（如定时器回调）中使用。

#### 4. 定时器回调函数（Lambda 表达式）
```cpp
auto broadcast_timer_callback = [this](){ ... };
```
*   这里使用了一个 **Lambda 表达式**来定义定时器到时后要执行的函数。
*   **`[this]`**: 这是**捕获列表**。它意味着 Lambda 函数体内部可以访问类成员（`this` 指针所指向的对象的所有成员），比如我们刚才创建的 `tf_broadcaster_`。
*   **`(){ ... }`**: 这是 Lambda 的函数体，包含了定时器触发时要执行的代码。

#### 5. 构建 TransformStamped 消息
这是回调函数的核心，它填充了要发送的坐标变换消息。

```cpp
geometry_msgs::msg::TransformStamped t;
```
创建一个 `TransformStamped` 类型的消息对象 `t`。这种消息类型包含了坐标变换的所有必要信息。

**设置时间戳和坐标系ID：**
```cpp
t.header.stamp = this->get_clock()->now();
t.header.frame_id = "turtle1";
t.child_frame_id = "carrot1";
```
*   **`header.stamp`**: **至关重要**。它指定了这个变换生效的时间。使用节点的时钟获取当前时间 (`now()`)，意味着这个变换“现在”有效。
*   **`header.frame_id`**: 父坐标系（参考坐标系）的名称。这里指的是 `carrot1` 坐标系是相对于 `turtle1` 坐标系来定义的。
*   **`child_frame_id`**: 子坐标系的名称。这是我们正在定义的这个坐标系。

**设置变换的具体内容（平移和旋转）：**
```cpp
t.transform.translation.x = 0.0;
t.transform.translation.y = 2.0;
t.transform.translation.z = 0.0;
```
这设置了平移量。它表示 `carrot1` 的原点在 `turtle1` 坐标系中的 `(x, y, z)` 位置是 `(0.0, 2.0, 0.0)`。也就是说，`carrot1` 在 `turtle1` 的正前方 2 米处。

```cpp
t.transform.rotation.x = 0.0;
t.transform.rotation.y = 0.0;
t.transform.rotation.z = 0.0;
t.transform.rotation.w = 1.0;
```
这设置了旋转量，用一个**四元数**来表示。`(x, y, z, w) = (0, 0, 0, 1)` 是一个**单位四元数**，代表**没有旋转**。因此，`carrot1` 的朝向与 `turtle1` 完全一致。

#### 6. 发送变换
```cpp
tf_broadcaster_->sendTransform(t);
```
使用之前创建的 `TransformBroadcaster` 的 `sendTransform` 方法，将我们填充好的 `TransformStamped` 消息 `t` 发布出去。这个消息会被发送到 `/tf` 主题（ROS 2 默认是 `/tf`，但 TF2 广播器和监听器会自动处理 topic 的命名）。

#### 7. 创建定时器
```cpp
timer_ = this->create_wall_timer(100ms, broadcast_timer_callback);
```
*   **`this->create_wall_timer`**: 调用从基类 `Node` 继承来的方法，创建一个**壁钟定时器**（Wall Timer），它基于系统的实时时钟，而不是模拟时钟。
*   **`100ms`**: 定时器的周期。C++ 字面量 `ms` 使得这里非常易读，表示 100 毫秒，即 0.1 秒，频率为 10Hz。
*   **`broadcast_timer_callback`**: 定时器到期时所要调用的函数，就是我们上面定义的 Lambda 表达式。
*   **`timer_ = ...`**: 将返回的定时器共享指针存储在私有成员变量 `timer_` 中，以确保定时器在对象存活期间持续有效。

#### 8. 私有成员变量
```cpp
private:
  rclcpp::TimerBase::SharedPtr timer_;
  std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
```
*   **`timer_`**: 一个指向定时器的共享指针。
*   **`tf_broadcaster_`**: 一个指向 TF2 变换广播器的共享指针。
将它们声明为 `private` 符合面向对象设计的封装原则，外部无法直接访问这些内部实现细节。

---

### 总结与关键点

1.  **目的**：持续发布一个静态的、固定的坐标系关系（`carrot1` 相对于 `turtle1`）。
2.  **机制**：使用一个定时器来**周期性地**发布相同的变换消息。即使变换是静态的，也需要持续发布，因为 TF2 系统默认只缓存很短时间内的变换数据。如果停止发布，这个变换关系很快就会从 TF 树中“过期”并被丢弃，导致监听器无法查询到。
3.  **消息类型**：`geometry_msgs::msg::TransformStamped`，这是 TF2 的标准消息格式。
4.  **重要字段**：
    *   `header.stamp`: 必须设置为当前时间。
    *   `header.frame_id` 和 `child_frame_id`: 定义了变换的方向（从谁到谁）。
    *   `transform`: 包含具体的平移向量和旋转四元数。
5.  **对于真正的静态变换**：虽然这段代码实现了功能，但对于**完全不会改变**的静态变换（比如机器人底座和激光雷达之间的固定连接），ROS 2 提供了更高效的工具：**`static_transform_publisher`** 命令行工具或 `tf2_ros::StaticTransformBroadcaster`。它们只在启动时发布一次变换，但会告知 TF2 系统这个变换是静态的，应该被永久缓存，从而节省了网络和计算资源。

这段代码是学习 ROS 2 TF2 系统的完美起点，它清晰地展示了发布一个坐标变换所需的所有基本步骤。