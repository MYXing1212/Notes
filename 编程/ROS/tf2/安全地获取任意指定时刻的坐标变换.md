这个页面是 ROS 2（Jazzy 版）官方文档中的一篇 **中级教程**，标题是 “Using time (C++)”。它专门讲 **如何在 C++ 里正确使用 tf2 的时间机制**，主要内容可以概括为一句话：

> **“教你在 tf2 里用 C++ 获取『指定时刻』的坐标变换，并在数据还没到时学会『等待』。”**

具体分成 3 个部分：

1. **背景**  
   - 之前教程里只会拿“最新”的变换；  
   - tf2 的缓冲里每个变换都带时间戳，默认保存 10 秒；  
   - 现在要学会拿“某个确切时间点”的变换，而不是“最新”。

2. **动手任务**  
   - **任务 1：把 listener 节点改成查询『当前时间』的变换**  
     把 `lookupTransform(…, tf2::TimePointZero)` 改成 `lookupTransform(…, this->get_clock()->now())`。  
     结果一运行就报错：  
     ```
     Lookup would require extrapolation into the future ...
     ```
     原因是：你索要“此刻”的变换，但广播器的数据还在路上，差几毫秒。

   - **任务 2：给 `lookupTransform()` 加一个『超时』参数**  
     改成  
     ```cpp
     tf_buffer_->lookupTransform(toFrame, fromFrame, now, 50ms);
     ```  
     这样函数会最多阻塞 50 ms，等数据到了再返回；如果 50 ms 内还是不到就抛异常。  
     改完后运行正常。

3. **总结**  
   - 学会了用 `lookupTransform()` 的第 4 个参数（timeout）让程序“等一等”，  
   - 从而安全地获取任意指定时刻的坐标变换。

一句话速记：  
**“这篇教程教你把 `lookupTransform()` 从『拿最新』升级为『拿指定时间并可等待』。”**


下面把 ROS 2 中 `lookupTransform()`（C++）/ `lookup_transform()`（Python）接口的“正确用法”和“典型使用场景”一次说清，并给出可直接拷贝运行的最小示例。  

──────────────────  
一、接口原型（C++）  
```cpp
geometry_msgs::msg::TransformStamped
tf2_ros::Buffer::lookupTransform(
    const std::string &target_frame,   // → 我要把数据转换到哪个坐标系
    const std::string &source_frame,   // → 数据当前所在的坐标系
    const tf2::TimePoint &time,        // → 查询哪个时刻的变换
    const tf2::Duration timeout = tf2::Duration(0)  // 可选阻塞超时
);
```
Python 对应接口  
```python
trans = tf_buffer.lookup_transform(
    target_frame, source_frame, time, timeout=rclpy.duration.Duration(seconds=0.0)
)
```

──────────────────  
二、正确用法 6 步曲  
1. 创建节点。  
2. 构造 `tf2_ros::Buffer`（C++）或 `tf2_ros.Buffer`（Python）。  
3. 把 Buffer 交给 `TransformListener`，让它在后台持续接收 TF 数据。  
   ⚠️ 常见坑：别把 `TransformListener` 声明成局部变量，否则离开作用域就停止监听。  
4. 需要查询时，直接调用 `lookupTransform()` / `lookup_transform()`。  
5. 用 try-catch（C++）或 try-except（Python）捕获 `tf2::TransformException`，避免节点崩溃。  
6. 如果查询“当前时刻”，建议加 `timeout`（如 50 ms）以等待数据到达。  

──────────────────  
三、典型使用场景  
1. 坐标系跟随  
   例：让 turtle2 始终跟随 turtle1。  
2. 传感器数据坐标变换  
   例：把激光雷达点云从 `laser_frame` 转到 `base_link`。  
3. 历史查询 / “时间旅行”  
   例：让机器人去 5 s 前胡萝卜所在的位置。  
4. 调试与可视化  
   例：在 rviz2 中实时查看任意两坐标系之间的位姿差。  

──────────────────  
四、最小可运行示例  
C++（ROS 2 Jazzy）：  
```cpp
#include <rclcpp/rclcpp.hpp>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>

class TfLookUpNode : public rclcpp::Node
{
public:
    TfLookUpNode()
        : Node("tf_lookup"), tf_buffer_(this->get_clock()), tf_listener_(tf_buffer_)
    {
        timer_ = create_wall_timer(
            std::chrono::milliseconds(500),
            [this]()
            {
                try
                {
                    auto t = tf_buffer_.lookupTransform(
                        "base_link", "laser", tf2::TimePointZero, tf2::Duration(0.05));
                    RCLCPP_INFO(this->get_logger(),
                                "laser→base_link: x=%.2f y=%.2f",
                                t.transform.translation.x,
                                t.transform.translation.y);
                }
                catch (const tf2::TransformException &ex)
                {
                    RCLCPP_WARN(this->get_logger(), "%s", ex.what());
                }
            });
    }

private:
    tf2_ros::Buffer tf_buffer_;
    tf2_ros::TransformListener tf_listener_;
    rclcpp::TimerBase::SharedPtr timer_;
};

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<TfLookUpNode>());
    rclcpp::shutdown();
    return 0;
}
```

Python（ROS 2 Humble）：  
```python
import rclpy
from rclpy.node import Node
from tf2_ros import TransformException, Buffer, TransformListener
from rclpy.duration import Duration

class TfLookupPy(Node):
    def __init__(self):
        super().__init__('tf_lookup_py')
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        self.timer = self.create_timer(0.5, self.timer_cb)

    def timer_cb(self):
        try:
            trans = self.tf_buffer.lookup_transform(
                'base_link', 'laser', rclpy.time.Time(), Duration(seconds=0.05))
            self.get_logger().info(
                f"laser→base_link: x={trans.transform.translation.x:.2f} "
                f"y={trans.transform.translation.y:.2f}")
        except TransformException as ex:
            self.get_logger().warn(str(ex))

def main():
    rclpy.init()
    node = TfLookupPy()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

──────────────────  
五、一句话总结  
“把 Buffer + TransformListener 常驻内存，查询时带 timeout 并捕获异常”，这就是 ROS 2 中 `lookupTransform()` 的全部正确姿势。 