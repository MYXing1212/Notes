这两段代码是用于**三维莫顿编码（Morton Encoding，又称Z阶曲线编码）**的实现的。下面分别解释它们的作用：

---

### **1. `expand64Bits(unsigned long long int v)`**
该函数接收一个21位的输入值（`v`），并通过特定的位扩展模式将其扩展成一个64位数，以便后续进行莫顿编码。

#### **功能说明：**
- 输入是一个21位数（`0x1fffff` 确保只保留低21位）。
- **在每一位之间插入零**，使其扩展成64位，便于后续的位交错操作。

#### **简化示例（8位情况）：**
如果 `v = 0b1011`（4位），扩展后可能变成类似 `0b100010001`（每两位之间插入两个零）。

#### **作用：**
莫顿编码需要将X、Y、Z三个坐标的**位交错排列**，该函数的作用就是**预先将每个坐标的位间隔开**，以便后续合并时能正确交错。

---

### **2. `morton3D(double x, double y, double z)`**
该函数用于计算给定三维坐标（x, y, z）的**莫顿编码**。

#### **执行步骤：**
1. **归一化 & 缩放**（`normX`、`normY`、`normZ`）：
   - 将输入坐标映射到固定范围（如 `[0, 1]`）。
   - 放大到21位整数（`scale = 1048576 = 2²⁰`）。
   - 确保值为正（`assert` 检查）。

2. **位扩展**（`expand64Bits`）：
   - 对X、Y、Z三个坐标分别进行位扩展，使其变成64位，并在位之间插入零。

3. **位交错合并**（`(xx << 2) | (yy << 1) | zz`）：
   - 将X、Y、Z的位交错排列：
     - **X** 的位放在 `...xxx...`（左移2位）。
     - **Y** 的位放在 `...yyy...`（左移1位）。
     - **Z** 的位放在 `...zzz...`（不移位）。
   - 最终结果：`...x y z x y z x y z...`（X、Y、Z位交错排列）。

#### **简化示例（2D情况）：**
- 设 `X = 0b10`（2），`Y = 0b11`（3）。
- 扩展后的X：`0b1000`（左移1位→`0b10000`）。
- 扩展后的Y：`0b0101`（不移位→`0b00101`）。
- 莫顿编码：`0b10000 | 0b00101 = 0b10101`（X=`10` 和 Y=`11` 交错→`1 1 0 1 0`）。

---

### **莫顿编码的用途**
- 主要用于**空间索引**（如八叉树、GPU光线追踪、空间数据库）。
- 将三维坐标映射到**一维Z阶曲线**，保持空间局部性。
- 在三维空间中邻近的点，其莫顿编码也通常相近。

### **关键点**
- `expand64Bits` 确保每个坐标的位被间隔开，便于交错。
- 最终的 `(xx << 2) | (yy << 1) | zz` 实现了X、Y、Z的**Z阶交错**。
- 缩放值 `1048576` 允许每个坐标使用21位，最终生成63位莫顿码（`21 × 3 = 63`）。

这是一种高度优化的莫顿编码实现，通常用于**高性能空间计算**（如物理引擎、光线追踪等）。