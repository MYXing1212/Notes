```python
def _get_observations(self) -> dict:
    self.velocity = self.robot.data.root_com_vel_w
    self.forwards = math_utils.quat_apply(self.robot.data.root_link_quat_w, self.robot.data.FORWARD_VEC_B)

	# self.forwards是机器人前进方向向量（在世界坐标系中），形状为 (num_envs, 3)
	# self.commands期望的目标方向向量，形状为 (num_envs, 3)
	# dim=-1：告诉 PyTorch “沿着哪一条轴做累加”
	# keepdim=True：告诉 PyTorch “做完累加后，把被压扁的那条轴保留成 1，而不是直接删掉”。
    dot = torch.sum(self.forwards * self.commands, dim=-1, keepdim=True)

	# dim=-1表示在最后一维（特征维）上做三维叉积。  
	# 要求：
-   #   self.forwards 与 self.commands 形状完全相同；
    #   最后一维长度必须是 3（三维向量）。  
    #   结果形状与输入完全一致，只是把每对 3-D 向量换成了它们的叉积 3-D 向量。  
    # 假设输入形状为 `[B, T, 3]`，则输出仍是 `[B, T, 3]`。
    cross = torch.cross(self.forwards, self.commands, dim=-1)[:,-1].reshape(-1,1)

	# self.robot.data.root_com_lin_vel_b：机器人质心在**本体坐标系**中的线速度，形状为 `(num_envs, 3)`
	# `[:,0]`: 取x分量（在本体坐标系中，x通常是前进方向）
    forward_speed = self.robot.data.root_com_lin_vel_b[:,0].reshape(-1,1)
    
	# - 最终观测向量形状: `(num_envs, 3)`
	# 每个环境获得一个3维观测
	obs = torch.hstack((dot, cross, forward_speed))

    observations = {"policy": obs}
    return observations
```